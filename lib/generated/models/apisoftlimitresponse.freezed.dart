// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'apisoftlimitresponse.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ApiSoftLimitResponse _$ApiSoftLimitResponseFromJson(Map<String, dynamic> json) {
  return _ApiSoftLimitResponse.fromJson(json);
}

/// @nodoc
mixin _$ApiSoftLimitResponse {
  @JsonKey(name: 'Stock')
  double? get stock => throw _privateConstructorUsedError;
  @JsonKey(name: 'Margin')
  double? get margin => throw _privateConstructorUsedError;
  @JsonKey(name: 'Future')
  double? get future => throw _privateConstructorUsedError;
  @JsonKey(name: 'FutureMini')
  double? get futureMini => throw _privateConstructorUsedError;
  @JsonKey(name: 'FutureMicro')
  double? get futureMicro => throw _privateConstructorUsedError;
  @JsonKey(name: 'Option')
  double? get option => throw _privateConstructorUsedError;
  @JsonKey(name: 'MiniOption')
  double? get miniOption => throw _privateConstructorUsedError;
  @JsonKey(name: 'KabuSVersion')
  String? get kabuSVersion => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ApiSoftLimitResponseCopyWith<ApiSoftLimitResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiSoftLimitResponseCopyWith<$Res> {
  factory $ApiSoftLimitResponseCopyWith(ApiSoftLimitResponse value,
          $Res Function(ApiSoftLimitResponse) then) =
      _$ApiSoftLimitResponseCopyWithImpl<$Res, ApiSoftLimitResponse>;
  @useResult
  $Res call(
      {@JsonKey(name: 'Stock') double? stock,
      @JsonKey(name: 'Margin') double? margin,
      @JsonKey(name: 'Future') double? future,
      @JsonKey(name: 'FutureMini') double? futureMini,
      @JsonKey(name: 'FutureMicro') double? futureMicro,
      @JsonKey(name: 'Option') double? option,
      @JsonKey(name: 'MiniOption') double? miniOption,
      @JsonKey(name: 'KabuSVersion') String? kabuSVersion});
}

/// @nodoc
class _$ApiSoftLimitResponseCopyWithImpl<$Res,
        $Val extends ApiSoftLimitResponse>
    implements $ApiSoftLimitResponseCopyWith<$Res> {
  _$ApiSoftLimitResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stock = freezed,
    Object? margin = freezed,
    Object? future = freezed,
    Object? futureMini = freezed,
    Object? futureMicro = freezed,
    Object? option = freezed,
    Object? miniOption = freezed,
    Object? kabuSVersion = freezed,
  }) {
    return _then(_value.copyWith(
      stock: freezed == stock
          ? _value.stock
          : stock // ignore: cast_nullable_to_non_nullable
              as double?,
      margin: freezed == margin
          ? _value.margin
          : margin // ignore: cast_nullable_to_non_nullable
              as double?,
      future: freezed == future
          ? _value.future
          : future // ignore: cast_nullable_to_non_nullable
              as double?,
      futureMini: freezed == futureMini
          ? _value.futureMini
          : futureMini // ignore: cast_nullable_to_non_nullable
              as double?,
      futureMicro: freezed == futureMicro
          ? _value.futureMicro
          : futureMicro // ignore: cast_nullable_to_non_nullable
              as double?,
      option: freezed == option
          ? _value.option
          : option // ignore: cast_nullable_to_non_nullable
              as double?,
      miniOption: freezed == miniOption
          ? _value.miniOption
          : miniOption // ignore: cast_nullable_to_non_nullable
              as double?,
      kabuSVersion: freezed == kabuSVersion
          ? _value.kabuSVersion
          : kabuSVersion // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ApiSoftLimitResponseImplCopyWith<$Res>
    implements $ApiSoftLimitResponseCopyWith<$Res> {
  factory _$$ApiSoftLimitResponseImplCopyWith(_$ApiSoftLimitResponseImpl value,
          $Res Function(_$ApiSoftLimitResponseImpl) then) =
      __$$ApiSoftLimitResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'Stock') double? stock,
      @JsonKey(name: 'Margin') double? margin,
      @JsonKey(name: 'Future') double? future,
      @JsonKey(name: 'FutureMini') double? futureMini,
      @JsonKey(name: 'FutureMicro') double? futureMicro,
      @JsonKey(name: 'Option') double? option,
      @JsonKey(name: 'MiniOption') double? miniOption,
      @JsonKey(name: 'KabuSVersion') String? kabuSVersion});
}

/// @nodoc
class __$$ApiSoftLimitResponseImplCopyWithImpl<$Res>
    extends _$ApiSoftLimitResponseCopyWithImpl<$Res, _$ApiSoftLimitResponseImpl>
    implements _$$ApiSoftLimitResponseImplCopyWith<$Res> {
  __$$ApiSoftLimitResponseImplCopyWithImpl(_$ApiSoftLimitResponseImpl _value,
      $Res Function(_$ApiSoftLimitResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stock = freezed,
    Object? margin = freezed,
    Object? future = freezed,
    Object? futureMini = freezed,
    Object? futureMicro = freezed,
    Object? option = freezed,
    Object? miniOption = freezed,
    Object? kabuSVersion = freezed,
  }) {
    return _then(_$ApiSoftLimitResponseImpl(
      stock: freezed == stock
          ? _value.stock
          : stock // ignore: cast_nullable_to_non_nullable
              as double?,
      margin: freezed == margin
          ? _value.margin
          : margin // ignore: cast_nullable_to_non_nullable
              as double?,
      future: freezed == future
          ? _value.future
          : future // ignore: cast_nullable_to_non_nullable
              as double?,
      futureMini: freezed == futureMini
          ? _value.futureMini
          : futureMini // ignore: cast_nullable_to_non_nullable
              as double?,
      futureMicro: freezed == futureMicro
          ? _value.futureMicro
          : futureMicro // ignore: cast_nullable_to_non_nullable
              as double?,
      option: freezed == option
          ? _value.option
          : option // ignore: cast_nullable_to_non_nullable
              as double?,
      miniOption: freezed == miniOption
          ? _value.miniOption
          : miniOption // ignore: cast_nullable_to_non_nullable
              as double?,
      kabuSVersion: freezed == kabuSVersion
          ? _value.kabuSVersion
          : kabuSVersion // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ApiSoftLimitResponseImpl implements _ApiSoftLimitResponse {
  const _$ApiSoftLimitResponseImpl(
      {@JsonKey(name: 'Stock') this.stock,
      @JsonKey(name: 'Margin') this.margin,
      @JsonKey(name: 'Future') this.future,
      @JsonKey(name: 'FutureMini') this.futureMini,
      @JsonKey(name: 'FutureMicro') this.futureMicro,
      @JsonKey(name: 'Option') this.option,
      @JsonKey(name: 'MiniOption') this.miniOption,
      @JsonKey(name: 'KabuSVersion') this.kabuSVersion});

  factory _$ApiSoftLimitResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ApiSoftLimitResponseImplFromJson(json);

  @override
  @JsonKey(name: 'Stock')
  final double? stock;
  @override
  @JsonKey(name: 'Margin')
  final double? margin;
  @override
  @JsonKey(name: 'Future')
  final double? future;
  @override
  @JsonKey(name: 'FutureMini')
  final double? futureMini;
  @override
  @JsonKey(name: 'FutureMicro')
  final double? futureMicro;
  @override
  @JsonKey(name: 'Option')
  final double? option;
  @override
  @JsonKey(name: 'MiniOption')
  final double? miniOption;
  @override
  @JsonKey(name: 'KabuSVersion')
  final String? kabuSVersion;

  @override
  String toString() {
    return 'ApiSoftLimitResponse(stock: $stock, margin: $margin, future: $future, futureMini: $futureMini, futureMicro: $futureMicro, option: $option, miniOption: $miniOption, kabuSVersion: $kabuSVersion)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiSoftLimitResponseImpl &&
            (identical(other.stock, stock) || other.stock == stock) &&
            (identical(other.margin, margin) || other.margin == margin) &&
            (identical(other.future, future) || other.future == future) &&
            (identical(other.futureMini, futureMini) ||
                other.futureMini == futureMini) &&
            (identical(other.futureMicro, futureMicro) ||
                other.futureMicro == futureMicro) &&
            (identical(other.option, option) || other.option == option) &&
            (identical(other.miniOption, miniOption) ||
                other.miniOption == miniOption) &&
            (identical(other.kabuSVersion, kabuSVersion) ||
                other.kabuSVersion == kabuSVersion));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, stock, margin, future,
      futureMini, futureMicro, option, miniOption, kabuSVersion);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiSoftLimitResponseImplCopyWith<_$ApiSoftLimitResponseImpl>
      get copyWith =>
          __$$ApiSoftLimitResponseImplCopyWithImpl<_$ApiSoftLimitResponseImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ApiSoftLimitResponseImplToJson(
      this,
    );
  }
}

abstract class _ApiSoftLimitResponse implements ApiSoftLimitResponse {
  const factory _ApiSoftLimitResponse(
          {@JsonKey(name: 'Stock') final double? stock,
          @JsonKey(name: 'Margin') final double? margin,
          @JsonKey(name: 'Future') final double? future,
          @JsonKey(name: 'FutureMini') final double? futureMini,
          @JsonKey(name: 'FutureMicro') final double? futureMicro,
          @JsonKey(name: 'Option') final double? option,
          @JsonKey(name: 'MiniOption') final double? miniOption,
          @JsonKey(name: 'KabuSVersion') final String? kabuSVersion}) =
      _$ApiSoftLimitResponseImpl;

  factory _ApiSoftLimitResponse.fromJson(Map<String, dynamic> json) =
      _$ApiSoftLimitResponseImpl.fromJson;

  @override
  @JsonKey(name: 'Stock')
  double? get stock;
  @override
  @JsonKey(name: 'Margin')
  double? get margin;
  @override
  @JsonKey(name: 'Future')
  double? get future;
  @override
  @JsonKey(name: 'FutureMini')
  double? get futureMini;
  @override
  @JsonKey(name: 'FutureMicro')
  double? get futureMicro;
  @override
  @JsonKey(name: 'Option')
  double? get option;
  @override
  @JsonKey(name: 'MiniOption')
  double? get miniOption;
  @override
  @JsonKey(name: 'KabuSVersion')
  String? get kabuSVersion;
  @override
  @JsonKey(ignore: true)
  _$$ApiSoftLimitResponseImplCopyWith<_$ApiSoftLimitResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}
